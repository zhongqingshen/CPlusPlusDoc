#include <iostream>
using namespace std;
//复合类型
  //定义：是指基于其他类型定义的类型，例如：指针和引用
  //引用(reference)：为对象取一个别名，引用类型引用另外一种类型，通过将声明符写成&P的形式来定义引用，P表示声明的变量
  //引用变量初始化和一般变量初始化有区别，变量初始化会将初始值拷贝至新建对象。引用定义是和初始值进行绑定而不是将初始值
  //进行拷贝，初始化完成后引用就和初始值绑定在一起。因为不能将引用绑定修改至其他对象，所以引用必须初始化
  //注意：引用不是一个对象，只是一个已存在对象的别名
void test()
{
	int value = 10;
	int &rValue = value;
	cout << "变量 value 的值：" << value << endl; // 10
	cout << "引用变量 rValue 的值：" << rValue << endl; // 10
	//int &rValue; //报错，&rValue必须被初始化 
	
	value = 20;
	cout << "修改后变量 value 的值：" << value << endl; // 20
	cout << "修改后引用变量 rValue 的值：" << rValue << endl; // 20
}

   //指针(Pointer)：一个指向另外一种对象的复合类型
   //指针值：
   //1.指向一个对象
   //2.指针紧邻对象所占用空间的下一个位置
   //3.空指针，一个没有指向的指针
   //4.上述情况以外的指针
   //如果需要访问一个对象需要使用解引用符(*p),p是指针
//使用未经初始化的指针会引起程序崩溃
void test1()
{
	int a = 10;
	int *p = &a; 
	cout << "a 的地址：" << a << endl;
	cout << "p 的地址：" << *p << endl;
	//获取指针的地址方式
	cout << "获取指针的地址方式：" << &p << endl;
}

void test2()
{
	int ival = 100;
	int *p = &ival;
	cout << "*p的值 " << *p << endl;//p指向的对象值
	cout << "p的值 " << p << endl; //p是指向ival的地址值
	cout << "ival 的值" << &ival << endl;//ival的地址值
	cout << "p的值 " << &p << endl;//p的地址值
	cout << "--------------------------------------" << endl;
	int i = 42;
	int *pi = &i;
	*pi = *pi * *pi;
	cout << "i的值" << i << endl;
	cout << "i的地址值" << &i << endl;
	cout << "pi的对象地址值" << pi << endl;
	cout << "pi的地址值" << &pi << endl;
	cout << "pi的引用对象值" << *pi << endl;

}

  //指针和引用的对比：
  //--------------------------------------------------
  //|            |    指针          | 引用            |
  //|-------------------------------------------------
  //|初始化      |      不需要       |  需要           |   
  //|修改        |      能修改       |  不能修改       | 
  //|-------------------------------------------------

//int main()
//{
	//test();
	//test1();
	//test2();
	/*system("pause");
	return 0;
}*/